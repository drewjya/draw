package design_test

import (
	"testing"

	design "github.com/gregoryv/go-design"
)

func Test_reference_document(t *testing.T) {
	var (
		account = design.NewComponent(Account{})
		ledger  = design.NewComponent(Ledger{})
		product = design.NewComponent(Product{})
		order   = design.NewComponent(Order{})
	)

	graph := design.NewGraph()
	graph.Place(account.WithFields()).At(30, 40)
	graph.Place(ledger.WithFields()).RightOf(account)
	graph.Place(order.WithFields()).Below(account)
	graph.Place(product).RightOf(order)

	design.AlignHorizontal(design.Center, account, ledger)
	design.AlignHorizontal(design.Center, order, product)
	design.AlignVertical(design.Center, account, order)
	design.AlignVertical(design.Center, ledger, product)

	graph.Link(account, ledger)
	graph.Link(order, product)
	graph.Link(order, account)
	//graph.Link(account, product) // invalid example

	doc := design.NewDocument()
	write := doc.Editor()
	write(
		"<h1>Example Go-Design Document</h1>",

		`<p>Keeping documentation such as design diagrams in sync with
code changes is a challenge whenever those are decoupled. The
go-design package solves this by enabling developers to write designs
as tests and have them updated with on shot using the <code>gofmt -r
'...' -w</code> command.</p>`,

		`<p>Reflection is used to find names of types and relations.
That way when creating graphs the package can verify wether or not the
source matches the graphs. Another nice property is that plain text
can be mixed with types, E.g. `,

		"\"<em>",
		Account{}, "s are the root connector of ", Order{}, "s.",
		"</em>\"<br><br>",
		graph,
		"<br><i>This document is generated by func ",
		"<b><code>Test_reference_document</code></b> test.</i>",
	)

	// Additional style can be added
	doc.Style = design.Plain(
		`body { width: 16cm; margin-left: 3cm }
h1 { margin-left: -2.5cm }
svg { border: 1px solid #e2e2e2; margin: auto }
code { background-color: #e2e2e2; }
`)

	doc.SaveAs("reference.html")
}

type Account struct {
	Username string
	password string
}

type Ledger struct {
	From, To *Account
	Total    int
}

type Product struct{}

type Order struct {
	First *Product
	Owner *Account
}
